#include <Chao/Chao.h>

#include <camera.h>
#include <playsound.h>

INLINE_ASM(_data, "asm/nonmatching/Chao/al_icon/data.src");

// batshit hack to be able to have the source file end with the program section
// so that we have the proper 00 padding generated by the last .ALIGN 32
// while still being able to use data
// without having to rip it all for now
#pragma inline_asm(_hack)
void _hack() { 
    .SECTION P, CODE, ALIGN=32 
}

void AL_IconReset(task* tp);

enum {
    RET_ICON_CONTINUE,
    RET_ICON_FINISH,
};

enum {
    ICON_TEX_NUM_TAMA = 0x0,
    ICON_TEX_NUM_BIKKURI = 0x1,
    ICON_TEX_NUM_HATENA = 0x2,
    ICON_TEX_NUM_HEART = 0x3,
    ICON_TEX_NUM_MOJYA = 0x4,
    ICON_TEX_NUM_TOGE = 0x5,
    ICON_TEX_NUM_TENSHI = 0x6,
    ICON_TEX_NUM_MARU = 0x7,
    ICON_TEX_NUM_BATSU = 0x8,
    ICON_TEX_NUM_LIGHT = 0x9,
    ICON_TEX_NUM_NONE = 0xA,
};

typedef struct ICON_COLOR {
    Uint8 col[3];
} ICON_COLOR;

extern int HeroIconNumberTable[181];
extern Uint16 nbFireTex;
extern Uint16 FireTexNum[16];
extern int (*AL_IconFuncList[6])(task*);
extern ICON_COLOR IconColorNeut[1];
extern ICON_COLOR IconColorHero[1];
extern ICON_COLOR IconColorDark[1];

#define lerp(a, b, t) (a * inv_##t + b * t)

void AL_CalcIconColor(task* tp) {
    chaowk* chao = GET_CHAOWK(tp);
    CHAO_PARAM* param = &chao->param;

    ICON_COLOR* pIconColorList;

    switch (param->type) {
        case TYPE_CHILD:
            break;
        case TYPE_N_NORMAL:
        case TYPE_N_SWIM:
        case TYPE_N_FLY:
        case TYPE_N_RUN:
        case TYPE_N_POWER:
            pIconColorList = &IconColorNeut[6 * (1 + (param->type - 5) / 3)];
            break;
        case TYPE_H_NORMAL:
        case TYPE_H_SWIM:
        case TYPE_H_FLY:
        case TYPE_H_RUN:
        case TYPE_H_POWER:
            pIconColorList = &IconColorHero[6 * (1 + (param->type - 6) / 3)];
            break;
        case TYPE_D_NORMAL:
        case TYPE_D_SWIM:
        case TYPE_D_FLY:
        case TYPE_D_RUN:
        case TYPE_D_POWER:
            pIconColorList = &IconColorDark[6 * (1 + (param->type - 7) / 3)];
            break;
    }

    switch (param->type) {
        case TYPE_CHILD: {
            ICON_COLOR* color_n0 = &IconColorNeut[0];
            ICON_COLOR* color_n1 = &IconColorNeut[1];
            ICON_COLOR* color_nh = &IconColorNeut[5];
            ICON_COLOR* color_nv = &IconColorNeut[3];

            ICON_COLOR* color_a0;
            ICON_COLOR* color_a1;
            ICON_COLOR* color_ah;
            ICON_COLOR* color_av;

            ICON_COLOR dst;
            int i;

            Float ratio_h = param->body.HPos;
            Float inv_ratio_h;
            Float div_ratio_h;
            Float ratio_v = param->body.VPos;
            Float inv_ratio_v;
            Float div_ratio_v;
            Float ratio_g = param->body.growth;
            Float inv_ratio_g;
            Float div_ratio_g;

            Float ratio_a = param->body.APos;
            Float inv_ratio_a;

            if (ratio_a >= 0.0f) {
                if (ratio_a > 1.0f) {
                    ratio_a = 1.0f;
                }

                inv_ratio_a = 1 - ratio_a;

                color_a0 = &IconColorHero[0];
                color_a1 = &IconColorHero[1];
                color_ah = &IconColorHero[5];
                color_av = &IconColorHero[3];
            } else {
                if (ratio_a < -1.0f) {
                    ratio_a = -1.0f;
                }

                ratio_a *= -1;

                inv_ratio_a = 1 - ratio_a;

                color_a0 = &IconColorDark[0];
                color_a1 = &IconColorDark[1];
                color_ah = &IconColorDark[5];
                color_av = &IconColorDark[3];
            }

            if (ratio_g > 1)
                ratio_g = 1;

            if (!ratio_h)
                ratio_h = 0.000001f;
            if (!ratio_v)
                ratio_v = 0.000001f;

            if (ratio_h > 1)
                ratio_h = 1;
            else if (ratio_h < -1)
                ratio_h = -1;

            if (ratio_h < 0.0f) {
                color_nh = color_nh - 1;
                color_ah = color_ah - 1;

                ratio_h = -ratio_h;
            }

            if (ratio_v > 1)
                ratio_v = 1;
            else if (ratio_v < -1)
                ratio_v = -1;

            if (ratio_v < 0.0f) {
                color_nv = color_nv - 1;
                color_av = color_av - 1;

                ratio_v = -ratio_v;
            }

            {
                inv_ratio_h = 1.0f - ratio_h;
                inv_ratio_v = 1.0f - ratio_v;
                inv_ratio_g = 1.0f - ratio_g;

                div_ratio_h = div_ratio_v = 1.0f / (ratio_h + ratio_v);
                div_ratio_h *= ratio_h;
                div_ratio_v *= ratio_v;

                for (i = 0; i < 3; ++i) {
                    float zhv, zhv2;
                    float zhvA2;

                    zhv = div_ratio_h * lerp(color_n1->col[i], color_nh->col[i], ratio_h) +
                          div_ratio_v * lerp(color_n1->col[i], color_nv->col[i], ratio_v);
                    zhv2 = (color_n0->col[i] * inv_ratio_g + zhv * ratio_g);

                    zhv = div_ratio_h * (color_a1->col[i] * inv_ratio_h + color_ah->col[i] * ratio_h) +
                          div_ratio_v * (color_a1->col[i] * inv_ratio_v + color_av->col[i] * ratio_v);
                    zhvA2 = (color_a0->col[i] * inv_ratio_g + zhv * ratio_g);

                    dst.col[i] = lerp(zhv2, zhvA2, ratio_a);
                }

                chao->Icon.Color = (dst.col[0] << 16) | (dst.col[1] << 8) | dst.col[2] | 0xFF000000;
            }
            break;
        }
        case TYPE_N_CHAOS:
            chao->Icon.Color = 0xFFFFFFFF;
            break;
        case TYPE_H_CHAOS:
            chao->Icon.Color = 0xFFFFFF00;
            break;
        case TYPE_D_CHAOS:
            chao->Icon.Color = 0xFFFFFFFF;
            break;
        default: {
            ICON_COLOR* color_n0 = &pIconColorList[0];
            ICON_COLOR* color_n1 = &pIconColorList[1];
            ICON_COLOR* color_h = &pIconColorList[5];
            ICON_COLOR* color_v = &pIconColorList[3];

            ICON_COLOR dst;
            int i;

            Float ratio_h = param->body.HPos;
            Float inv_ratio_h;
            Float div_ratio_h;
            Float ratio_v = param->body.VPos;
            Float inv_ratio_v;
            Float div_ratio_v;
            Float ratio_g = param->body.growth;
            Float inv_ratio_g;
            Float div_ratio_g;

            Float ratio_a = param->body.APos;

            if (ratio_g > 1)
                ratio_g = 1;

            if (!ratio_h)
                ratio_h = 0.000001f;
            if (!ratio_v)
                ratio_v = 0.000001f;

            if (ratio_h > 1)
                ratio_h = 1;
            else if (ratio_h < -1)
                ratio_h = -1;

            if (ratio_h < 0.0f) {
                color_h = &pIconColorList[4];

                ratio_h = -ratio_h;
            }

            if (ratio_v > 1)
                ratio_v = 1;
            else if (ratio_v < -1)
                ratio_v = -1;

            if (ratio_v < 0.0f) {
                color_v = &pIconColorList[2];

                ratio_v = -ratio_v;
            }

            inv_ratio_h = 1.0f - ratio_h;
            inv_ratio_v = 1.0f - ratio_v;
            inv_ratio_g = 1.0f - ratio_g;

            div_ratio_h = div_ratio_v = 1.0f / (ratio_h + ratio_v);
            div_ratio_h *= ratio_h;
            div_ratio_v *= ratio_v;

            for (i = 0; i < 3; ++i) {
                float col = div_ratio_h * (color_n1->col[i] * inv_ratio_h + color_h->col[i] * ratio_h) +
                            div_ratio_v * (color_n1->col[i] * inv_ratio_v + color_v->col[i] * ratio_v);
                dst.col[i] = (color_n0->col[i] * inv_ratio_g + col * ratio_g);
            }

            chao->Icon.Color = (dst.col[0] << 16) | (dst.col[1] << 8) | dst.col[2] | 0xFF000000;

            break;
        }
    }
}

void AL_IconResetPos(task* tp);
void AL_IconInit(task* tp) {
    chaowk* work = GET_CHAOWK(tp);
    AL_ICON* pIcon = &work->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    pIcon->PuniPhase = NJM_DEG_ANG(njRandom() * 360.f);
    pIcon->PosPhase = NJM_DEG_ANG(njRandom() * 360.f);

    pUpper->Velo.x = 0;
    pUpper->Velo.y = 0;
    pUpper->Velo.z = 0;

    pUpper->Offset.x = 0;
    pUpper->Offset.y = 0;
    pUpper->Offset.z = 0;

    pUpper->Scl.x = 3.5f;
    pUpper->Scl.y = 3.5f;
    pUpper->Scl.z = 1.f;

    pIcon->Pos.x = pLower->Pos.x = pUpper->Pos.x = work->pos.x;
    pIcon->Pos.y = pLower->Pos.y = pUpper->Pos.y = work->pos.y + 5.f;
    pIcon->Pos.z = pLower->Pos.z = pUpper->Pos.z = work->pos.z;

    pLower->Velo.x = 0;
    pLower->Velo.y = 0;
    pLower->Velo.z = 0;

    pLower->Offset.x = 0;
    pLower->Offset.y = 0;
    pLower->Offset.z = 0;

    pLower->Scl.x = 1.f;
    pLower->Scl.y = 1.f;
    pLower->Scl.z = 1.f;

    pUpper->TexNum = ICON_TEX_NUM_NONE;
    pLower->TexNum = ICON_TEX_NUM_TAMA;

    AL_IconReset(tp);
    AL_IconResetPos(tp);
}

int AL_IconNormal(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->TexNum = ICON_TEX_NUM_NONE;

            pUpper->Offset.x = 0;
            pUpper->Offset.y = 0;
            pUpper->Offset.z = 0;

            pUpper->Scl.x = 0;
            pUpper->Scl.y = 0;

            pUpper->Mode++;
            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->TexNum = ICON_TEX_NUM_TAMA;

            pLower->Offset.x = 0;
            pLower->Offset.y = 0;
            pLower->Offset.z = 0;

            pLower->Mode++;
            break;
    }

    if (pIcon->NextType != -1)
        return RET_ICON_FINISH;

    return RET_ICON_CONTINUE;
}

int AL_IconBikkuri(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->TexNum = ICON_TEX_NUM_BIKKURI;

            pUpper->Offset.x = 0;
            pUpper->Offset.y = 0;
            pUpper->Offset.z = 0;

            pUpper->Scl.x = 0;
            pUpper->Scl.y = 0;

            pUpper->Mode++;
            break;

        case 1:
            pUpper->Offset.y += 0.48f;
            if (pUpper->Offset.y > 2.f)
                pUpper->Offset.y = 2.f;

            pUpper->Scl.x += 0.23f;
            if (pUpper->Scl.x > 3.2f)
                pUpper->Scl.x = 3.2f;

            pUpper->Scl.y += 0.23f;
            if (pUpper->Scl.y > 3.2f)
                pUpper->Scl.y = 3.2f;

            if (pIcon->Timer <= 0)
                pUpper->Mode++;
            break;

        case 2:
            pUpper->Offset.y -= 0.22f;

            if (pUpper->Offset.y < 0.f) {
                pUpper->Offset.y = 0.f;
                return RET_ICON_FINISH;
            }

            pUpper->Scl.x -= 0.28f;
            if (pUpper->Scl.x < 0)
                pUpper->Scl.x = 0;

            pUpper->Scl.y -= 0.28f;
            if (pUpper->Scl.y < 0)
                pUpper->Scl.y = 0;

            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->TexNum = ICON_TEX_NUM_TAMA;

            pLower->Offset.x = 0;
            pLower->Offset.y = 0;
            pLower->Offset.z = 0;

            pLower->Mode++;
            break;
    }

    return RET_ICON_CONTINUE;
}

int AL_IconHirameki(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->Mode++;
            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->Mode++;
            break;
    }

    return RET_ICON_CONTINUE;
}

int AL_IconHatena(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->TexNum = ICON_TEX_NUM_HATENA;

            pUpper->Offset.x = 0;
            pUpper->Offset.y = 0;
            pUpper->Offset.z = 0;

            pUpper->Scl.x = 0;
            pUpper->Scl.y = 0;

            pUpper->Mode++;
            break;

        case 1:
            pUpper->Offset.y += 0.48f;
            if (pUpper->Offset.y > 2.5f)
                pUpper->Offset.y = 2.5f;

            pUpper->Scl.x += 0.21f;
            if (pUpper->Scl.x > 4.f)
                pUpper->Scl.x = 4.f;

            pUpper->Scl.y += 0.21f;
            if (pUpper->Scl.y > 4.f)
                pUpper->Scl.y = 4.f;

            if (pIcon->Timer <= 0)
                pUpper->Mode++;
            break;

        case 2:
            pUpper->Offset.y -= 0.2f;

            if (pUpper->Offset.y < 0.f) {
                pUpper->Offset.y = 0.f;
                return RET_ICON_FINISH;
            }

            pUpper->Scl.x -= 0.3f;
            if (pUpper->Scl.x < 0)
                pUpper->Scl.x = 0;

            pUpper->Scl.y -= 0.3f;
            if (pUpper->Scl.y < 0)
                pUpper->Scl.y = 0;

            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->TexNum = ICON_TEX_NUM_TAMA;

            pLower->Offset.x = 0;
            pLower->Offset.y = 0;
            pLower->Offset.z = 0;

            pLower->Mode++;
            break;
    }

    return RET_ICON_CONTINUE;
}

int AL_IconHeart(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->TexNum = ICON_TEX_NUM_HEART;

            pUpper->Offset.x = 0;
            pUpper->Offset.y = 0;
            pUpper->Offset.z = 0;

            pUpper->Scl.x = 0;
            pUpper->Scl.y = 0;

            pUpper->Mode++;
            break;

        case 1:
            pUpper->Offset.y += 0.1f;
            if (pUpper->Offset.y > 0.7f)
                pUpper->Offset.y = 0.7f;

            pUpper->Scl.x += 0.2f;
            if (pUpper->Scl.x > 2.8f)
                pUpper->Scl.x = 2.8f;

            pUpper->Scl.y += 0.2f;
            if (pUpper->Scl.y > 2.8f)
                pUpper->Scl.y = 2.8f;

            if (pIcon->Timer <= 0)
                pUpper->Mode++;
            break;

        case 2:
            pUpper->Offset.y -= 0.08f;

            if (pUpper->Offset.y < 0.f) {
                pUpper->Offset.y = 0.f;
            }

            pUpper->Scl.x -= 0.25f;
            if (pUpper->Scl.x < 0)
                pUpper->Scl.x = 0;

            pUpper->Scl.y -= 0.25f;
            if (pUpper->Scl.y < 0)
                pUpper->Scl.y = 0;

            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->TexNum = ICON_TEX_NUM_TAMA;

            pLower->Offset.x = 0;
            pLower->Offset.y = 0;
            pLower->Offset.z = 0;

            pLower->Mode++;
            break;
        case 1:
            pLower->Scl.x -= 0.1f;
            if (pLower->Scl.x < 0)
                pLower->Scl.x = 0;

            pLower->Scl.y -= 0.1f;
            if (pLower->Scl.y < 0)
                pLower->Scl.y = 0;

            if (pIcon->Timer <= 0)
                pLower->Mode++;
            break;
        case 2:
            pLower->Scl.x += 0.05f;
            if (pLower->Scl.x > 1) {
                pLower->Scl.x = 1;
                return RET_ICON_FINISH;
            }

            pLower->Scl.y += 0.05f;
            if (pLower->Scl.y > 1)
                pLower->Scl.y = 1;
            break;
    }

    return RET_ICON_CONTINUE;
}

int AL_IconMojya(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    switch (pUpper->Mode) {
        case 0:
            pUpper->TexNum = ICON_TEX_NUM_MOJYA;

            pUpper->Offset.x = 0;
            pUpper->Offset.y = 0;
            pUpper->Offset.z = 0;

            pUpper->Scl.x = 0;
            pUpper->Scl.y = 0;

            pUpper->Mode++;
            break;

        case 1:
            pUpper->Offset.y += 0.1f;
            if (pUpper->Offset.y > 1.3f)
                pUpper->Offset.y = 1.3f;

            pUpper->Offset.x -= 0.1f;
            if (pUpper->Offset.x < -0.9f)
                pUpper->Offset.x = -0.9f;

            pUpper->Scl.x += 0.23f;
            if (pUpper->Scl.x > 3)
                pUpper->Scl.x = 3;

            pUpper->Scl.y += 0.23f;
            if (pUpper->Scl.y > 3)
                pUpper->Scl.y = 3;

            if (pIcon->Timer <= 0)
                pUpper->Mode++;
            break;

        case 2:
            pUpper->Offset.y -= 0.09f;
            if (pUpper->Offset.y < 0.f)
                pUpper->Offset.y = 0.f;

            pUpper->Offset.x += 0.08f;
            if (pUpper->Offset.x > 0)
                pUpper->Offset.x = 0;

            pUpper->Scl.x -= 0.25f;
            if (pUpper->Scl.x < 0)
                pUpper->Scl.x = 0;

            pUpper->Scl.y -= 0.25f;
            if (pUpper->Scl.y < 0)
                pUpper->Scl.y = 0;

            break;
    }

    switch (pLower->Mode) {
        case 0:
            pLower->TexNum = ICON_TEX_NUM_TAMA;

            pLower->Offset.x = 0;
            pLower->Offset.y = 0;
            pLower->Offset.z = 0;

            pLower->Mode++;
            break;
        case 1:
            pLower->Scl.x -= 0.1f;
            if (pLower->Scl.x < 0)
                pLower->Scl.x = 0;

            pLower->Scl.y -= 0.1f;
            if (pLower->Scl.y < 0)
                pLower->Scl.y = 0;

            if (pIcon->Timer <= 0)
                pLower->Mode++;
            break;
        case 2:
            pLower->Scl.x += 0.05f;
            if (pLower->Scl.x > 1) {
                pLower->Scl.x = 1;
                return RET_ICON_FINISH;
            }

            pLower->Scl.y += 0.05f;
            if (pLower->Scl.y > 1)
                pLower->Scl.y = 1;
            break;
    }

    return RET_ICON_CONTINUE;
}

void AL_IconShapeControl(task* tp) {
    chaowk* work = GET_CHAOWK(tp);
    AL_ICON* pIcon = &work->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;
    int result = AL_IconFuncList[pIcon->CurrType](tp);

    if (result == RET_ICON_FINISH) {
        if (pIcon->NextType == -1) {
            pIcon->CurrType = 0;
            pIcon->Timer = 0;
        } else {
            pIcon->CurrType = pIcon->NextType;
            pIcon->NextType = -1;

            pIcon->Timer = pIcon->NextTimer;
        }
        pUpper->Mode = 0;
        pUpper->Timer = 0;
        pLower->Mode = 0;
        pLower->Timer = 0;
    }

    if (pIcon->Timer > 0)
        pIcon->Timer--;

    pLower->Timer++;
    pUpper->Timer++;
}

void AL_IconResetPos(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    NJS_POINT3 Aim;

    NJS_POINT3* pLowerPos = &pLower->Pos;
    NJS_POINT3* pLowerVelo = &pLower->Velo;
    NJS_POINT3* pUpperPos = &pUpper->Pos;
    NJS_POINT3* pUpperVelo = &pUpper->Velo;

    AL_IconShapeControl(tp);

    Aim.x = pIcon->Pos.x;
    Aim.y = pIcon->Pos.y + pLower->Offset.y;
    Aim.z = pIcon->Pos.z;
    *pLowerPos = Aim;

    pLowerVelo->x = 0;
    pLowerVelo->y = 0;
    pLowerVelo->z = 0;

    Aim.x = pLowerPos->x;
    Aim.y = pLowerPos->y + pUpper->Offset.y;
    Aim.z = pLowerPos->z;
    *pUpperPos = Aim;

    pUpperVelo->x = 0;
    pUpperVelo->y = 0;
    pUpperVelo->z = 0;
}

void AL_IconControl(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;

    NJS_POINT3 Aim;

    NJS_POINT3* pLowerPos = &pLower->Pos;
    NJS_POINT3* pLowerVelo = &pLower->Velo;
    NJS_POINT3* pUpperPos = &pUpper->Pos;
    NJS_POINT3* pUpperVelo = &pUpper->Velo;

    AL_IconShapeControl(tp);

    Aim.x = pIcon->Pos.x;
    Aim.y = pIcon->Pos.y + pLower->Offset.y;
    Aim.z = pIcon->Pos.z;
    {
        float diffx = Aim.x - pLowerPos->x;
        float diffy = Aim.y - pLowerPos->y;
        float diffz = Aim.z - pLowerPos->z;

        if (diffy > 0.8f) {
            pLowerPos->y = Aim.y - 0.8f;
            diffy = 0.8f;
        } else if (diffy < -1) {
            pLowerPos->y = Aim.y + 1;
            diffy = -1;
        }

        pLowerVelo->x += diffx * 0.11f;
        pLowerVelo->y += diffy * 0.1f;
        pLowerVelo->z += diffz * 0.11f;

        pLowerVelo->x *= 0.9f;
        pLowerVelo->y *= 0.95f;
        pLowerVelo->z *= 0.9f;

        pLowerPos->x += pLowerVelo->x;
        pLowerPos->y += pLowerVelo->y;
        pLowerPos->z += pLowerVelo->z;
    }

    Aim.x = pLowerPos->x;
    Aim.y = pLowerPos->y + pUpper->Offset.y;
    Aim.z = pLowerPos->z;
    {
        float diffx = Aim.x - pUpperPos->x;
        float diffy = Aim.y - pUpperPos->y;
        float diffz = Aim.z - pUpperPos->z;

        if (diffx > 0.7f) {
            pUpperPos->x = Aim.x - 0.7f;
            diffx = 0.7f;
        } else if (diffx < -0.7) {
            pUpperPos->x = Aim.x + 0.7f;
            diffx = -0.7f;
        }

        if (diffy > 0.7f) {
            pUpperPos->y = Aim.y - 0.7f;
            diffy = 0.7f;
        } else if (diffy < -0.7f) {
            pUpperPos->y = Aim.y + 0.7f;
            diffy = -0.7f;
        }

        if (diffz > 0.7f) {
            pUpperPos->z = Aim.z - 0.7f;
            diffz = 0.7f;
        } else if (diffz < -0.7f) {
            pUpperPos->z = Aim.z + 0.7f;
            diffz = -0.7f;
        }

        pUpperVelo->x += diffx * 0.5f;
        pUpperVelo->y += diffy * 0.1f;
        pUpperVelo->z += diffz * 0.5f;

        pUpperVelo->x *= 0.45f;
        pUpperVelo->y *= 0.8f;
        pUpperVelo->z *= 0.45f;

        pUpperPos->x += pUpperVelo->x;
        pUpperPos->y += pUpperVelo->y;
        pUpperPos->z += pUpperVelo->z;
    }

    pIcon->PuniPhase += 1920;

    if (++pIcon->TexAnimTimer > 2) {
        pIcon->TexAnimTimer = 0;

        pIcon->TexAnimNum++;
        if (pIcon->TexAnimNum > nbFireTex - 1) {
            pIcon->TexAnimNum = 0;
        }
    }

    pIcon->ang = NJM_DEG_ANG(njRandom() * 360.f);
}

// there are two most likely fake matches here, i commented them
// maybe they're not fake, no clue
void AL_IconDraw(task* tp) {
    chaowk* work = GET_CHAOWK(tp);
    AL_ICON* pIcon = &work->Icon;
    AL_ICON_INFO* pUpper = &pIcon->Upper;
    AL_ICON_INFO* pLower = &pIcon->Lower;
    NJS_POINT3* pLowerPos = &pLower->Pos;
    NJS_POINT2 pos0;
    NJS_POINT2 pos1;

    NJS_COLOR offset;

    NJS_TEXTURE_VTX poly[4];

    {
        NJS_POINT3 vpos;

        vpos.x = pLowerPos->x + pIcon->Up.x;
        vpos.y = pLowerPos->y + pIcon->Up.y;
        vpos.z = pLowerPos->z + pIcon->Up.z;

        njProjectScreen(NULL, pLowerPos, &pos0);
        njProjectScreen(NULL, &vpos, &pos1);
    }

    offset.color = work->Icon.Color;

    njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
    njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_INVSRCALPHA);

    poly[0].x = -0.55f;
    poly[0].y = -0.55f;
    poly[0].z = -0.3;
    poly[0].u = 0.0;
    poly[0].v = 0.0;
    poly[0].col = offset.color;
    poly[1].x = -0.55f;
    poly[1].y = 0.55f;
    poly[1].z = -0.3;
    poly[1].u = 0.0;
    poly[1].v = 1.0;
    poly[1].col = offset.color;
    poly[2].x = 0.55f;
    poly[2].y = -0.55f;
    poly[2].z = -0.3;
    poly[2].u = 1.0;
    poly[2].v = 0.0;
    poly[2].col = offset.color;
    poly[3].x = 0.55f;
    poly[3].y = 0.55f;
    poly[3].z = -0.3;
    poly[3].u = 1.0;
    poly[3].v = 1.0;
    poly[3].col = offset.color;

    if (pUpper->TexNum != ICON_TEX_NUM_NONE) {
        NJS_POINT3 pos;
        float sclx, scly;

        njCalcPoint(NULL, &pUpper->Pos, &pos);

        {
            float y = pos.y;
            if ((GET_CHAOWK(tp)->flag & 0x8000)) {
                y += 0.7f;
            } else {
                y += -0.3f;
            }
            pos.y = y;
        }

        njPushMatrix(&_nj_unit_matrix_);

        sclx = 0.92f + 0.08 * (1 + njSin(pIcon->PuniPhase + 0x4000));
        scly = 2 - sclx;

        sclx *= pUpper->Scl.x;
        scly *= pUpper->Scl.y;

        pos.x += pUpper->Offset.x;

        njSetTexture(&AL_ICON_TEXLIST);
        njSetTextureNum(pUpper->TexNum);

        njTranslateV(NULL, &pos);

        // fake match #1
        if (0) {
            njDrawTexture3DEx(NULL, 4, 1);
        }

        njScale(NULL, sclx, scly, 0.1f);

        njDrawTexture3DEx(poly, 4, 1);

        njPopMatrixEx();
    }

    {
        float sclx, scly;
        CHAO_PARAM* pParam;
        NJS_POINT3 pos;
        NJS_VECTOR vec;

        njCalcPoint(NULL, &pLower->Pos, &pos);

        {
            float y = pos.y;
            if ((GET_CHAOWK(tp)->flag & 0x8000)) {
                y += 0.7f;
            } else {
                y += -0.3f;
            }
            pos.y = y;
        }

        njPushMatrix(&_nj_unit_matrix_);

        pParam = GET_CHAOPARAM(tp);
        sclx = 0.08 * (1 + njSin(pIcon->PuniPhase)) + 0.92f;
        scly = 2 - sclx;

        sclx *= pLower->Scl.x;
        scly *= pLower->Scl.y;

        // fake match #2
        if (1)
            ;
        else
            pParam->type = 0;

        njTranslateV(NULL, &pos);
        njSetTexture(&AL_ICON_TEXLIST);

        switch (pParam->body.HonbuNum) {
            case HONBU_NORMAL:
                if (pParam->type >= TYPE_H_NORMAL && !((pParam->type - TYPE_H_NORMAL) % 3)) {
                    // hero halo

                    float inner;
                    int ang;
                    int index;

                    float diffx, diffy;
                    Angle angz;

                    camcontwk* pCam = cameraControlWork[0];

                    vec.x = pLowerPos->x - pCam->pos.x;
                    vec.y = pLowerPos->y - pCam->pos.y;
                    vec.z = pLowerPos->z - pCam->pos.z;

                    if (njScalor(&vec) > 0.0000001f) {
                        njUnitVector(&vec);
                    } else {
                        vec.x = 0;
                        vec.y = 1;
                        vec.z = 0;
                    }

                    inner = njInnerProduct(&vec, &pIcon->Up);
                    ang = njArcCos(-inner);

                    sclx *= 2;
                    scly *= 2;

                    index = NJM_ANG_DEG(ang) + 0.5f;
                    // index = index % 181; // on sa2b aswell, missing here

                    njSetTextureNum(6 + HeroIconNumberTable[index]);

                    diffx = pos1.x - pos0.x; // this is negated on sa2b..?
                    diffy = pos1.y - pos0.y;

                    angz = njArcTan2(-diffx, -diffy);
                    njRotateZ(NULL, -angz);

                    njScale(NULL, sclx, scly, 1.f);

                    if (pParam->type == TYPE_H_CHAOS) {
                        njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
                        njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_ONE);
                    }

                    njDrawTexture3DEx(poly, 4, 1);
                } else if (pParam->type >= TYPE_D_NORMAL && !((pParam->type - TYPE_D_NORMAL) % 3)) {
                    // dark ball

                    sclx *= 1.5f;
                    scly *= 1.5f;

                    if (pParam->type != TYPE_D_CHAOS) {
                        njSetTextureNum(5);
                        njScale(NULL, sclx, scly, 1);
                        njDrawTexture3DEx(poly, 4, 1);
                    }
                    else {
                        njSetTextureNum(FireTexNum[pIcon->TexAnimNum]);
                        njScale(NULL, sclx, scly, 1);

                        njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
                        njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_ONE);
                        njDrawTexture3DEx(poly, 4, 1);
                    }
                } else {
                    if (pParam->type != TYPE_N_CHAOS) {
                        njSetTextureNum(pLower->TexNum);

                        njScale(NULL, sclx, scly, 1);
                        njDrawTexture3DEx(poly, 4, 1);
                    }
                    else {
                        njSetTextureNum(6);

                        njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
                        njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_ONE);

                        njRotateZ(NULL, pIcon->ang);
                        njScale(NULL, 1.5f * sclx, 1.5f * scly, 1);
                        njDrawTexture3DEx(poly, 4, 1);
                    }
                }
                break;
            case HONBU_FIRE_OBAKE:
                njSetTextureNum(FireTexNum[pIcon->TexAnimNum]);
                njScale(NULL, sclx, scly, 1);

                njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
                njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_ONE);

                njDrawTexture3DEx(poly, 4, 1);
                break;
        }

        njPopMatrixEx();

        njColorBlendingMode(NJD_SOURCE_COLOR, NJD_COLOR_BLENDING_SRCALPHA);
        njColorBlendingMode(NJD_DESTINATION_COLOR, NJD_COLOR_BLENDING_INVSRCALPHA);
    }
}

void AL_IconSet(task* tp, Sint8 Type, int Timer) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;

    pIcon->NextType = Type;
    pIcon->Timer = 0;
    pIcon->NextTimer = Timer;

    sub_8C05B020(0x100E, 0, 0, 0, &GET_CHAOWK(tp)->pos);
}

void AL_IconReset(task* tp) {
    AL_ICON* pIcon = &GET_CHAOWK(tp)->Icon;

    pIcon->NextType = 0;
    pIcon->Timer = 0;
    pIcon->NextTimer = 0;
}
